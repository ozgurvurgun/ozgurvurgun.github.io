<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>@ozgurvurgun | NestJS</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:image" content><link rel=alternate type=application/rss+xml href=https://ozgurvurgun.github.io/nestjs/index.xml title=@ozgurvurgun><meta property="og:title" content="NestJS"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://ozgurvurgun.github.io/nestjs/"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJS"><meta name=twitter:description content><script src=https://ozgurvurgun.github.io/js/feather.min.js></script>
<link href=https://ozgurvurgun.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://ozgurvurgun.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://ozgurvurgun.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css media="(prefers-color-scheme: dark)"><style>input[type=text],input[type=password]{font-size:16px!important;touch-action:manipulation}</style></head><body><div class=content><header><div class=main><a href=https://ozgurvurgun.github.io/>@ozgurvurgun</a></div><nav><a href=/>main</a>
<a href=/shorts>shorts</a>
<a href=/projects>projects</a>
<a href=/angular>angular</a>
<a href=/nestjs>nestJS</a>
<a href=/links>links</a>
<a href=/about>me</a></nav></header><main class=list><div class=site-description></div><section class=list-item><h1 class=title><a href=/nestjs/1-what-is-nestjs/>Giriş Temel Bİlgiler</a></h1><time>Jul 29, 2025</time><br><div class=description>NestJS&rsquo;e Giriş: Neden Yeni Bir Şeye Daha İhtiyacımız Var? Node.js harika. JavaScript&rsquo;in gücünü sunucu tarafına taşıdı, “Aynı dili hem frontend&rsquo;de hem backend&rsquo;de kullanma” rüyasını gerçeğe dönüştürdü. Ama ne zaman ki işler büyüdü, bu özgürlük başımıza bela olmaya başladı. Çünkü:
Herkes her şeyi her yerde yapabiliyordu. Proje büyüdükçe dosyalar çöplüğe dönebiliyordu. Kod tekrarları, karışık business logic, zor test edilebilir yapılar ortaya çıkıyordu. İşte NestJS burada sahneye çıkıyor.
NestJS Nedir? NestJS, TypeScript ile yazılmış, modüler bir backend framework&rsquo;üdür.&mldr;</div><a class=readmore href=/nestjs/1-what-is-nestjs/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/2-ilk-nestjs-uygulamasi/>İlk NestJS Uygulaması</a></h1><time>Jul 29, 2025</time><br><div class=description>NestJS Projesine İlk Adım Artık teoriyi kenara bırakıp işe girişme zamanı. Bu yazıda, sıfırdan bir NestJS projesi oluşturup çalıştıracağız. “Hello World” endpoint’imizi yazacak, klasörleri tanıyacak, ve uygulamanın yaşam döngüsünü anlayacağız.
Amaç: NestJS&rsquo;e dair temel taşları yerine oturtmak. Ezberlemeden, sindirerek ilerlemek.
1. NestJS CLI ile Proje Oluşturma NestJS, Angular&rsquo;dan esinlenmiş bir yapı sunduğu için, benzer şekilde bir CLI (Command Line Interface) aracı sunar.
Kurulum:
npm i -g @nestjs/cli Yeni proje oluştur:&mldr;</div><a class=readmore href=/nestjs/2-ilk-nestjs-uygulamasi/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/3-nestjs-mimarisi-temel-kavramlar-1/>NestJS Mimarisi: Modüller ve Temel Kavramlar (1. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>Neden Modül? Küçük projelerde her şeyi tek dosyada yazmak kolaydır. Ama işler büyüyünce işler sarpa sarar. Kod karmaşıklaşır, neyin nerede olduğunu bulmak zorlaşır. İşte burada modüller devreye girer.
NestJS, Angular&rsquo;dan aldığı ilhamla “her şey bir modülün içinde” prensibiyle çalışır.
Bir modül, belirli bir işlevi yerine getiren yapıları gruplar: controller&rsquo;lar, service&rsquo;ler, provider&rsquo;lar&mldr;
1. Modül Nedir? NestJS’te her yapı bir modülün içinde yaşar.
Modül; bağımsız, izole, bir iş parçasını temsil eden bir yapıdır.&mldr;</div><a class=readmore href=/nestjs/3-nestjs-mimarisi-temel-kavramlar-1/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/>NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>Modüller Arası İletişim Neden Önemlidir? Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.
Örneğin:
Kullanıcı kaydı yapılınca log&rsquo;a bir şey yazmak isteyebilirsin. Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin. Yani modüllerin birbiriyle konuşması gerekir.
NestJS bunu imports, exports ve dependency injection sistemleriyle sağlar.
Temel Kurgu: Service Kullanmak Senaryomuz şu:
UserService adında bir servisimiz var (UserModule içinde) AuthModule bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için) Şöyle bir şey yapmak istiyoruz:&mldr;</div><a class=readmore href=/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/5-nestjs-mimarisi-temel-kavramlar-3/>NestJS Mimarisi: Dinamik Modüller ve Yapılandırma (3. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>Dinamik Modül Nedir? Normal modüller sabittir. İçine neyi yazdıysan, sistem onu kullanır.
Ama bazen bir modülün kurulum aşamasında parametre alması gerekir.
Yani modülün davranışı dışarıdan gelen bir yapılandırmaya göre değişmelidir.
İşte burada dinamik modül devreye girer.
Gerçek Hayat Senaryosu Diyelim ki bir MailerModule yazıyorsun.
Geliştirme ortamında log’a yazmasını, Gerçek ortamda ise SMTP sunucusuna mail atmasını istiyorsun. Yani modül şunu demeli:
“Ben dışarıdan bana nasıl davranacağım söylensin istiyorum.”
Nasıl Tanımlanır? Dinamik modül, static register() veya static registerAsync() metotlarıyla tanımlanır.&mldr;</div><a class=readmore href=/nestjs/5-nestjs-mimarisi-temel-kavramlar-3/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/6-nestjs-mimarisi-temel-kavramlar-4/>NestJS Mimarisi: Global Modüller ve Kullanım Senaryoları (4. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>Global Modül Nedir? NestJS&rsquo;te bir modül normalde sadece import edildiği yerde kullanılır.
Yani UserModule içinde tanımlı bir UserService, sadece onu import eden modüller tarafından erişilebilir.
Ama bazı modüller vardır ki:
“Beni her yerden erişilebilir yap” demek ister.
İşte bu tür modüller için global modül kavramı vardır.
Nasıl Tanımlanır? Bir modülü global yapmak için @Global() dekoratörünü kullanırız.
// logger.module.ts @Global() @Module({ providers: [LoggerService], exports: [LoggerService], }) export class LoggerModule {} Artık bu modülü AppModule&lsquo;de bir kez import etmek yeterlidir:&mldr;</div><a class=readmore href=/nestjs/6-nestjs-mimarisi-temel-kavramlar-4/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/7-nestjs-mimarisi-temel-kavramlar-5/>NestJS Mimarisi: Controller Nedir? Ne Değildir? (5. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>Controller Nedir? NestJS&rsquo;te Controller, gelen HTTP isteklerini karşılayan yapıdır.
Yani dış dünyadan gelen tüm GET, POST, PUT, DELETE istekleri burada karşılanır.
Kısaca: Controller = API’nin giriş noktasıdır.
Router mı bu? Express kullanmış olanlar için şöyle bir benzetme yapalım:
// Express app.get('/users', handler); // NestJS @Controller('users') export class UserController { @Get() getAll() { return 'user listesi'; } } Arka planda aslında Express (veya Fastify) hala çalışıyor. Ama NestJS bunu sınıflar ve dekoratörlerle daha okunabilir ve organize bir hâle getiriyor.&mldr;</div><a class=readmore href=/nestjs/7-nestjs-mimarisi-temel-kavramlar-5/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/8-nestjs-mimarisi-temel-kavramlar-6/>NestJS Mimarisi: Controller’da Request ve Response Nesnelerinin Kullanımı (6. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>NestJS’te Request ve Response Nesneleri NestJS, altında Express (veya Fastify) kullanır.
Yani istersen alışılagelmiş req, res nesnelerine erişebilirsin.
Ama NestJS bunun yerine decorator temelli bir yaklaşım sunar.
Yani doğrudan req.body yerine @Body() kullanırsın.
res.send() yerine doğrudan return yaparsın.
Peki nasıl ve neden?
@Req() ve @Res() Nedir? @Req(): HTTP isteğini temsil eden Request objesini verir. (Express tipindedir)
@Get() handleRequest(@Req() req: Request) { console.log(req.headers['user-agent']); return 'Gelen istek işlendi'; } @Res(): Manuel olarak yanıt oluşturmak istediğinde kullanılır.&mldr;</div><a class=readmore href=/nestjs/8-nestjs-mimarisi-temel-kavramlar-6/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/9-nestjs-mimarisi-temel-kavramlar-7/>NestJS Mimarisi: Status Code Yönetimi (7. Bölüm)</a></h1><time>Jul 29, 2025</time><br><div class=description>HTTP Status Code Nedir? Neden Önemlidir? Bir API sadece veri döndürmez.
Her cevabın bir anlamı olmalıdır. Bu anlamı taşıyan şey de status code&rsquo;tur.
return { message: 'Başarılı!' }; Bu cevap 200 OK ile gelir mi? 201 Created mi? Yoksa 400 Bad Request mi? İşte bu çok kritik. Çünkü:
Status code = İstemciye ne olduğunu anlatan işaret lambasıdır.
NestJS’te Status Code Nasıl Yönetilir? En sade yol: @HttpCode() dekoratörüdür.
@Post() @HttpCode(201) createUser() { return { message: 'Kullanıcı oluşturuldu' }; } Bu örnekte POST /users isteğine dönüş 201 Created olacaktır.&mldr;</div><a class=readmore href=/nestjs/9-nestjs-mimarisi-temel-kavramlar-7/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/nestjs/10-nestjs-mimarisi-temel-kavramlar-8/>NestJS Mimarisi: Global Exception Handle (8. Bölüm)</a></h1><time>Jul 30, 2025</time><br><div class=description>Hata Fırlatmak Yetmez, Yakalamak da Gerekir Hatalar kaçınılmaz. Ama kontrolsüz hata = üretimde patlayan sistem = sinirli müşteri = uykusuz geliştirici.
NestJS bu durumu çözmek için merkezî bir hata yakalama mekanizması sunar: Global Exception Filter
Şimdiye Kadar Ne Yaptık? Şöyle kodlar yazdık:
if (!userExists(id)) { throw new NotFoundException('Kullanıcı bulunamadı'); } Ve Nest bunu alıp güzelce 404 yanıtıyla döndü. Harika.
Ama ya özel bir hata sınıfı yazmak istiyorsan? Ya da her hatayı { status, errorCode, message, timestamp } gibi özel bir formatta döndürmek istiyorsan?&mldr;</div><a class=readmore href=/nestjs/10-nestjs-mimarisi-temel-kavramlar-8/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"></span><span class="page-item page-next"><a href=/nestjs/page/2/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><div style=display:flex><a class=soc href=https://github.com/ozgurvurgun rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://linkedin.com/in/ozgurvurgun1 rel=me title=Linkedin><i data-feather=linkedin></i></a>
<a class=border></a><a class=soc href=http://emre.xyz/me.vcf rel=me title=VCF><i data-feather=phone></i></a>
<a class=border></a><a class=soc href=http://emre.xyz/resume.pdf rel=me title=Resume><i data-feather=file-text></i></a>
<a class=border></a></div><div class=footer-info>2025 ozgurvurgun</div></footer><script>feather.replace()</script><script src=https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js></script>
<script>const keyInput=document.getElementById("key"),contentEl=document.getElementById("content"),encryptedText=contentEl.textContent.trim();keyInput.addEventListener("input",()=>{const e=keyInput.value.trim();if(!e){contentEl.textContent=encryptedText;return}try{const n=CryptoJS.AES.decrypt(encryptedText,e),t=n.toString(CryptoJS.enc.Utf8);if(!t)throw new Error("Çözülemedi");contentEl.textContent=t}catch{contentEl.textContent=encryptedText}})</script></div></body></html>