<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NestJS on @ozgurvurgun</title><link>https://ozgurvurgun.github.io/nestjs/</link><description>Recent content in NestJS on @ozgurvurgun</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>ozgurvurgun</copyright><lastBuildDate>Wed, 30 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ozgurvurgun.github.io/nestjs/index.xml" rel="self" type="application/rss+xml"/><item><title>Giriş Temel Bİlgiler</title><link>https://ozgurvurgun.github.io/nestjs/1-what-is-nestjs/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/1-what-is-nestjs/</guid><description>NestJS&amp;rsquo;e Giriş: Neden Yeni Bir Şeye Daha İhtiyacımız Var? Node.js harika. JavaScript&amp;rsquo;in gücünü sunucu tarafına taşıdı, “Aynı dili hem frontend&amp;rsquo;de hem backend&amp;rsquo;de kullanma” rüyasını gerçeğe dönüştürdü. Ama ne zaman ki işler büyüdü, bu özgürlük başımıza bela olmaya başladı. Çünkü:
Herkes her şeyi her yerde yapabiliyordu. Proje büyüdükçe dosyalar çöplüğe dönebiliyordu. Kod tekrarları, karışık business logic, zor test edilebilir yapılar ortaya çıkıyordu. İşte NestJS burada sahneye çıkıyor.
NestJS Nedir? NestJS, TypeScript ile yazılmış, modüler bir backend framework&amp;rsquo;üdür.</description></item><item><title>İlk NestJS Uygulaması</title><link>https://ozgurvurgun.github.io/nestjs/2-ilk-nestjs-uygulamasi/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/2-ilk-nestjs-uygulamasi/</guid><description>NestJS Projesine İlk Adım Artık teoriyi kenara bırakıp işe girişme zamanı. Bu yazıda, sıfırdan bir NestJS projesi oluşturup çalıştıracağız. “Hello World” endpoint’imizi yazacak, klasörleri tanıyacak, ve uygulamanın yaşam döngüsünü anlayacağız.
Amaç: NestJS&amp;rsquo;e dair temel taşları yerine oturtmak. Ezberlemeden, sindirerek ilerlemek.
1. NestJS CLI ile Proje Oluşturma NestJS, Angular&amp;rsquo;dan esinlenmiş bir yapı sunduğu için, benzer şekilde bir CLI (Command Line Interface) aracı sunar.
Kurulum:
npm i -g @nestjs/cli Yeni proje oluştur:</description></item><item><title>NestJS Mimarisi: Modüller ve Temel Kavramlar (1. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/3-nestjs-mimarisi-temel-kavramlar-1/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/3-nestjs-mimarisi-temel-kavramlar-1/</guid><description>Neden Modül? Küçük projelerde her şeyi tek dosyada yazmak kolaydır. Ama işler büyüyünce işler sarpa sarar. Kod karmaşıklaşır, neyin nerede olduğunu bulmak zorlaşır. İşte burada modüller devreye girer.
NestJS, Angular&amp;rsquo;dan aldığı ilhamla “her şey bir modülün içinde” prensibiyle çalışır.
Bir modül, belirli bir işlevi yerine getiren yapıları gruplar: controller&amp;rsquo;lar, service&amp;rsquo;ler, provider&amp;rsquo;lar&amp;hellip;
1. Modül Nedir? NestJS’te her yapı bir modülün içinde yaşar.
Modül; bağımsız, izole, bir iş parçasını temsil eden bir yapıdır.</description></item><item><title>NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/</guid><description>Modüller Arası İletişim Neden Önemlidir? Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.
Örneğin:
Kullanıcı kaydı yapılınca log&amp;rsquo;a bir şey yazmak isteyebilirsin. Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin. Yani modüllerin birbiriyle konuşması gerekir.
NestJS bunu imports, exports ve dependency injection sistemleriyle sağlar.
Temel Kurgu: Service Kullanmak Senaryomuz şu:
UserService adında bir servisimiz var (UserModule içinde) AuthModule bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için) Şöyle bir şey yapmak istiyoruz:</description></item><item><title>NestJS Mimarisi: Dinamik Modüller ve Yapılandırma (3. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/5-nestjs-mimarisi-temel-kavramlar-3/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/5-nestjs-mimarisi-temel-kavramlar-3/</guid><description>Dinamik Modül Nedir? Normal modüller sabittir. İçine neyi yazdıysan, sistem onu kullanır.
Ama bazen bir modülün kurulum aşamasında parametre alması gerekir.
Yani modülün davranışı dışarıdan gelen bir yapılandırmaya göre değişmelidir.
İşte burada dinamik modül devreye girer.
Gerçek Hayat Senaryosu Diyelim ki bir MailerModule yazıyorsun.
Geliştirme ortamında log’a yazmasını, Gerçek ortamda ise SMTP sunucusuna mail atmasını istiyorsun. Yani modül şunu demeli:
“Ben dışarıdan bana nasıl davranacağım söylensin istiyorum.”
Nasıl Tanımlanır? Dinamik modül, static register() veya static registerAsync() metotlarıyla tanımlanır.</description></item><item><title>NestJS Mimarisi: Global Modüller ve Kullanım Senaryoları (4. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/6-nestjs-mimarisi-temel-kavramlar-4/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/6-nestjs-mimarisi-temel-kavramlar-4/</guid><description>Global Modül Nedir? NestJS&amp;rsquo;te bir modül normalde sadece import edildiği yerde kullanılır.
Yani UserModule içinde tanımlı bir UserService, sadece onu import eden modüller tarafından erişilebilir.
Ama bazı modüller vardır ki:
“Beni her yerden erişilebilir yap” demek ister.
İşte bu tür modüller için global modül kavramı vardır.
Nasıl Tanımlanır? Bir modülü global yapmak için @Global() dekoratörünü kullanırız.
// logger.module.ts @Global() @Module({ providers: [LoggerService], exports: [LoggerService], }) export class LoggerModule {} Artık bu modülü AppModule&amp;lsquo;de bir kez import etmek yeterlidir:</description></item><item><title>NestJS Mimarisi: Controller Nedir? Ne Değildir? (5. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/7-nestjs-mimarisi-temel-kavramlar-5/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/7-nestjs-mimarisi-temel-kavramlar-5/</guid><description>Controller Nedir? NestJS&amp;rsquo;te Controller, gelen HTTP isteklerini karşılayan yapıdır.
Yani dış dünyadan gelen tüm GET, POST, PUT, DELETE istekleri burada karşılanır.
Kısaca: Controller = API’nin giriş noktasıdır.
Router mı bu? Express kullanmış olanlar için şöyle bir benzetme yapalım:
// Express app.get(&amp;#39;/users&amp;#39;, handler); // NestJS @Controller(&amp;#39;users&amp;#39;) export class UserController { @Get() getAll() { return &amp;#39;user listesi&amp;#39;; } } Arka planda aslında Express (veya Fastify) hala çalışıyor. Ama NestJS bunu sınıflar ve dekoratörlerle daha okunabilir ve organize bir hâle getiriyor.</description></item><item><title>NestJS Mimarisi: Controller’da Request ve Response Nesnelerinin Kullanımı (6. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/8-nestjs-mimarisi-temel-kavramlar-6/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/8-nestjs-mimarisi-temel-kavramlar-6/</guid><description>NestJS’te Request ve Response Nesneleri NestJS, altında Express (veya Fastify) kullanır.
Yani istersen alışılagelmiş req, res nesnelerine erişebilirsin.
Ama NestJS bunun yerine decorator temelli bir yaklaşım sunar.
Yani doğrudan req.body yerine @Body() kullanırsın.
res.send() yerine doğrudan return yaparsın.
Peki nasıl ve neden?
@Req() ve @Res() Nedir? @Req(): HTTP isteğini temsil eden Request objesini verir. (Express tipindedir)
@Get() handleRequest(@Req() req: Request) { console.log(req.headers[&amp;#39;user-agent&amp;#39;]); return &amp;#39;Gelen istek işlendi&amp;#39;; } @Res(): Manuel olarak yanıt oluşturmak istediğinde kullanılır.</description></item><item><title>NestJS Mimarisi: Status Code Yönetimi (7. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/9-nestjs-mimarisi-temel-kavramlar-7/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/9-nestjs-mimarisi-temel-kavramlar-7/</guid><description>HTTP Status Code Nedir? Neden Önemlidir? Bir API sadece veri döndürmez.
Her cevabın bir anlamı olmalıdır. Bu anlamı taşıyan şey de status code&amp;rsquo;tur.
return { message: &amp;#39;Başarılı!&amp;#39; }; Bu cevap 200 OK ile gelir mi? 201 Created mi? Yoksa 400 Bad Request mi? İşte bu çok kritik. Çünkü:
Status code = İstemciye ne olduğunu anlatan işaret lambasıdır.
NestJS’te Status Code Nasıl Yönetilir? En sade yol: @HttpCode() dekoratörüdür.
@Post() @HttpCode(201) createUser() { return { message: &amp;#39;Kullanıcı oluşturuldu&amp;#39; }; } Bu örnekte POST /users isteğine dönüş 201 Created olacaktır.</description></item><item><title>NestJS Mimarisi: Global Exception Handle (8. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/10-nestjs-mimarisi-temel-kavramlar-8/</link><pubDate>Wed, 30 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/10-nestjs-mimarisi-temel-kavramlar-8/</guid><description>Hata Fırlatmak Yetmez, Yakalamak da Gerekir Hatalar kaçınılmaz. Ama kontrolsüz hata = üretimde patlayan sistem = sinirli müşteri = uykusuz geliştirici.
NestJS bu durumu çözmek için merkezî bir hata yakalama mekanizması sunar: Global Exception Filter
Şimdiye Kadar Ne Yaptık? Şöyle kodlar yazdık:
if (!userExists(id)) { throw new NotFoundException(&amp;#39;Kullanıcı bulunamadı&amp;#39;); } Ve Nest bunu alıp güzelce 404 yanıtıyla döndü. Harika.
Ama ya özel bir hata sınıfı yazmak istiyorsan? Ya da her hatayı { status, errorCode, message, timestamp } gibi özel bir formatta döndürmek istiyorsan?</description></item><item><title>NestJS Mimarisi: Headers ve Query Parametreleri Okuma (9. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/11-nestjs-mimarisi-temel-kavramlar-9/</link><pubDate>Wed, 30 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/11-nestjs-mimarisi-temel-kavramlar-9/</guid><description>HTTP İsteği Sadece Body&amp;rsquo;den İbaret Değil API’ye gelen her istek 3 temel veri kaynağı taşır:
Body -&amp;gt; İçerik, payload Query -&amp;gt; Filtre, arama, sayfalama gibi şeyler Headers -&amp;gt; Kimlik, token, dil bilgisi, içerik türü Ve bunların her biri farklı ihtiyaçlara hizmet eder. NestJS bu üçüne de ayrı dekoratörler sunar.
Bu bölümde @Query() ve @Headers() üzerinde duracağız.
@Query() - Sorgu Parametrelerini Okumak
Örnek URL:
GET /products?page=2&amp;amp;limit=10&amp;amp;sort=price Bu URL&amp;rsquo;deki page, limit ve sort kısmı query parametresidir.</description></item><item><title>NestJS Mimarisi: Route Wildcard ve Prefixler (10. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/12-nestjs-mimarisi-temel-kavramlar-10/</link><pubDate>Wed, 30 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/12-nestjs-mimarisi-temel-kavramlar-10/</guid><description/></item></channel></rss>