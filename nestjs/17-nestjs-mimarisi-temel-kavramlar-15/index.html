<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>@ozgurvurgun | NestJS Mimarisi: Provider Scope (15. Bölüm)</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Bir Servis, Herkes İçin Aynı mıdır? NestJS’te @Injectable() bir sınıf tanımladığında, varsayılan olarak bu servis singleton olur:
Tüm uygulama boyunca sadece 1 kez oluşturulur ve herkes aynı örneği kullanır.
Ama bu her zaman ideal değildir.
Bazı durumlarda:
Her HTTP isteği için yeni bir örnek gerekebilir (örneğin kullanıcıya özel veri taşımak) Her dependency injection noktası farklı bir örnek almalıdır İşte burada scope kavramı devreye girer.
3 Temel Scope Türü Scope Yaşam Süresi Kullanım Senaryosu SINGLETON Tüm uygulama boyunca 1 örnek Varsayılan, çoğu servis bu olur REQUEST Her HTTP isteği için yeni Kullanıcıya özel veri tutan servisler TRANSIENT Her kullanımda yeni örnek Paylaşılmaması gereken servisler (stateless) 1."><meta property="og:image" content><meta property="og:title" content="NestJS Mimarisi: Provider Scope (15. Bölüm)"><meta property="og:description" content="Bir Servis, Herkes İçin Aynı mıdır? NestJS’te @Injectable() bir sınıf tanımladığında, varsayılan olarak bu servis singleton olur:
Tüm uygulama boyunca sadece 1 kez oluşturulur ve herkes aynı örneği kullanır.
Ama bu her zaman ideal değildir.
Bazı durumlarda:
Her HTTP isteği için yeni bir örnek gerekebilir (örneğin kullanıcıya özel veri taşımak) Her dependency injection noktası farklı bir örnek almalıdır İşte burada scope kavramı devreye girer.
3 Temel Scope Türü Scope Yaşam Süresi Kullanım Senaryosu SINGLETON Tüm uygulama boyunca 1 örnek Varsayılan, çoğu servis bu olur REQUEST Her HTTP isteği için yeni Kullanıcıya özel veri tutan servisler TRANSIENT Her kullanımda yeni örnek Paylaşılmaması gereken servisler (stateless) 1."><meta property="og:type" content="article"><meta property="og:url" content="https://ozgurvurgun.github.io/nestjs/17-nestjs-mimarisi-temel-kavramlar-15/"><meta property="article:section" content="nestJS"><meta property="article:published_time" content="2025-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJS Mimarisi: Provider Scope (15. Bölüm)"><meta name=twitter:description content="Bir Servis, Herkes İçin Aynı mıdır? NestJS’te @Injectable() bir sınıf tanımladığında, varsayılan olarak bu servis singleton olur:
Tüm uygulama boyunca sadece 1 kez oluşturulur ve herkes aynı örneği kullanır.
Ama bu her zaman ideal değildir.
Bazı durumlarda:
Her HTTP isteği için yeni bir örnek gerekebilir (örneğin kullanıcıya özel veri taşımak) Her dependency injection noktası farklı bir örnek almalıdır İşte burada scope kavramı devreye girer.
3 Temel Scope Türü Scope Yaşam Süresi Kullanım Senaryosu SINGLETON Tüm uygulama boyunca 1 örnek Varsayılan, çoğu servis bu olur REQUEST Her HTTP isteği için yeni Kullanıcıya özel veri tutan servisler TRANSIENT Her kullanımda yeni örnek Paylaşılmaması gereken servisler (stateless) 1."><script src=https://ozgurvurgun.github.io/js/feather.min.js></script>
<link href=https://ozgurvurgun.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://ozgurvurgun.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://ozgurvurgun.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css media="(prefers-color-scheme: dark)"><style>input[type=text],input[type=password]{font-size:16px!important;touch-action:manipulation}</style></head><body><div class=content><header><div class=main><a href=https://ozgurvurgun.github.io/>@ozgurvurgun</a></div><nav><a href=/>main</a>
<a href=/shorts>shorts</a>
<a href=/projects>projects</a>
<a href=/angular>angular</a>
<a href=/nestjs>nestJS</a>
<a href=/links>links</a>
<a href=/about>me</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>NestJS Mimarisi: Provider Scope (15. Bölüm)</h1><div class=meta>Posted on Jul 31, 2025</div></div><section class=body><h2 id=bir-servis-herkes-için-aynı-mıdır>Bir Servis, Herkes İçin Aynı mıdır?</h2><p>NestJS’te <code>@Injectable()</code> bir sınıf tanımladığında, varsayılan olarak bu servis singleton olur:</p><blockquote><p>Tüm uygulama boyunca sadece 1 kez oluşturulur ve herkes aynı örneği kullanır.</p></blockquote><p>Ama bu her zaman ideal değildir.</p><p>Bazı durumlarda:</p><ul><li>Her HTTP isteği için yeni bir örnek gerekebilir (örneğin kullanıcıya özel veri taşımak)</li><li>Her dependency injection noktası farklı bir örnek almalıdır</li></ul><p>İşte burada <code>scope</code> kavramı devreye girer.</p><h2 id=3-temel-scope-türü>3 Temel Scope Türü</h2><table><thead><tr><th>Scope</th><th>Yaşam Süresi</th><th>Kullanım Senaryosu</th></tr></thead><tbody><tr><td><code>SINGLETON</code></td><td>Tüm uygulama boyunca 1 örnek</td><td>Varsayılan, çoğu servis bu olur</td></tr><tr><td><code>REQUEST</code></td><td>Her HTTP isteği için yeni</td><td>Kullanıcıya özel veri tutan servisler</td></tr><tr><td><code>TRANSIENT</code></td><td>Her kullanımda yeni örnek</td><td>Paylaşılmaması gereken servisler (stateless)</td></tr></tbody></table><h2 id=1-singleton-varsayılan>1. Singleton (Varsayılan)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {}
</span></span></code></pre></div><p>Yukarıdaki gibi hiçbir şey yazmazsan <code>SINGLETON</code> olur.</p><ul><li>App ayağa kalkarken oluşturulur.</li><li>Her yerde aynı örnek kullanılır.</li></ul><p>Avantajları:</p><ul><li>Performanslı</li><li>Bellek dostu</li></ul><p>Ama:</p><ul><li>Durum (state) tutuyorsa, herkes bu durumu paylaşır = tehlikeli</li></ul><h2 id=2-request-scoped>2. Request Scoped</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>({ <span style=color:#a6e22e>scope</span>: <span style=color:#66d9ef>Scope.REQUEST</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserContextService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#a6e22e>REQUEST</span>) <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>req</span>: <span style=color:#66d9ef>Request</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getUserId() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>user</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>id</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bu servis her HTTP isteği için yeniden oluşturulur.
Yani <code>UserContextService</code> artık o isteğe özel veriyle çalışır.</p><p>Kullanım alanları:</p><ul><li>Kullanıcı kimliği</li><li>İstek başına değişen veriler</li><li>Loglama, trace id, tenant ID gibi metadata</li></ul><p>Dikkat:</p><ul><li>Performansı düşürebilir (her istek için yeni nesne)</li><li>Tüm bağımlılıkları da request-scoped olmalı ya da dikkatlice paylaşılmalı</li></ul><h2 id=3-transient-scoped>3. Transient Scoped</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>({ <span style=color:#a6e22e>scope</span>: <span style=color:#66d9ef>Scope.TRANSIENT</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UniqueIdGenerator</span> {}
</span></span></code></pre></div><p>Bu scope, her <code>constructor()</code> çağrısında yeni bir örnek oluşturur.</p><p>Örnek:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>generator</span>: <span style=color:#66d9ef>UniqueIdGenerator</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>OrderService</code> her çağrıldığında yeni bir <code>UniqueIdGenerator</code> örneği alır.
Yani aynı servis bile olsa, her injection noktası farklı nesne alır.</p><p>Kullanım senaryosu:</p><ul><li>Kısa ömürlü, durum tutan servisler</li><li>Her iş parçası kendi verisini üretmeli</li><li>Paralel işlerde paylaşım riskliyse</li></ul><h2 id=felsefi-açıdan>Felsefi Açıdan&mldr;</h2><p>Scope aslında şunu sorar:</p><blockquote><p>Bu servis ne kadar yaşamalı, kimlerle paylaşılmalı?</p></blockquote><p>Bu da yazılımda yaşam süresi yönetimi (lifetime management) ve bağımlılık izolasyonu gibi kavramlara dokunur.</p><ul><li>Singleton: Herkesin ortak kullanacağı şeyler (config, sabit servisler)</li><li>Request: Kullanıcıya göre değişen veriler</li><li>Transient: Herkesin kendine özel anlık ihtiyaçları</li></ul><h2 id=injectable-ile-tanımlamak>@Injectable() ile Tanımlamak</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>({ <span style=color:#a6e22e>scope</span>: <span style=color:#66d9ef>Scope.REQUEST</span> })
</span></span></code></pre></div><p>veya</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>({ <span style=color:#a6e22e>scope</span>: <span style=color:#66d9ef>Scope.TRANSIENT</span> })
</span></span></code></pre></div><p><code>Scope</code> enum&rsquo;u şuradan gelir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>Injectable</span>, <span style=color:#a6e22e>Scope</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/common&#39;</span>;
</span></span></code></pre></div><h2 id=request-sabitine-ulaşmak>REQUEST Sabitine Ulaşmak</h2><p><code>@Inject(REQUEST)</code> ile Express isteğini yakalayabilirsin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>REQUEST</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@nestjs/core&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#a6e22e>REQUEST</span>) <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>req</span>: <span style=color:#66d9ef>Request</span>) {}
</span></span></code></pre></div><p>Ama bu sadece <code>Scope.REQUEST</code> ile çalışan servislerde işe yarar.</p><h2 id=örnek-uygulama-kullanıcıya-özel-servis>Örnek Uygulama: Kullanıcıya Özel Servis</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>({ <span style=color:#a6e22e>scope</span>: <span style=color:#66d9ef>Scope.REQUEST</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CurrentUserService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#a6e22e>REQUEST</span>) <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>req</span>: <span style=color:#66d9ef>Request</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getUser() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>user</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ve bu servis tüm controller’larda <code>@Inject()</code> edilerek kullanılabilir.</p><h2 id=dikkat-etmen-gerekenler>Dikkat Etmen Gerekenler</h2><ul><li>Request-scoped bir servis, singleton bir servise inject edilemez.
Tersine ise sorun yok.</li><li>Transient kullanımında dikkat: Performans maliyeti var ama paylaşım riski sıfır.</li><li>Tüm sistemini request-scoped yapmak “temiz” görünebilir ama ölçeklenebilir değildir.</li><li>Gerekmedikçe singleton dışına çıkma.</li></ul><h2 id=ne-nerede-kullanılır>Ne Nerede Kullanılır?</h2><table><thead><tr><th>Durum</th><th>Scope Seçimi</th></tr></thead><tbody><tr><td>Config, Logger, MailService</td><td><code>SINGLETON</code></td></tr><tr><td>Authenticated User, Request Context</td><td><code>REQUEST</code></td></tr><tr><td>İşlem bazlı stateful servis (örneğin PDF Builder)</td><td><code>TRANSIENT</code></td></tr><tr><td>Her injection’da yeni ID, yeni veri</td><td><code>TRANSIENT</code></td></tr></tbody></table><h2 id=sonuç>Sonuç</h2><ul><li>NestJS’te servislerin yaşam süresi <code>scope</code> ile kontrol edilir.</li><li>Varsayılan <code>singleton</code>, ama ihtiyaç varsa <code>request</code> veya <code>transient</code> seçebilirsin.</li><li>Doğru yerde doğru scope kullanmak sisteminin güvenliğini ve performansını doğrudan etkiler.</li><li>Gereksiz yere farklı scope kullanmak hem performansı düşürür hem sistemi karmaşıklaştırır.</li></ul></section><div class=post-tags></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/ozgurvurgun rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://linkedin.com/in/ozgurvurgun1 rel=me title=Linkedin><i data-feather=linkedin></i></a>
<a class=border></a><a class=soc href=http://emre.xyz/me.vcf rel=me title=VCF><i data-feather=phone></i></a>
<a class=border></a><a class=soc href=http://emre.xyz/resume.pdf rel=me title=Resume><i data-feather=file-text></i></a>
<a class=border></a></div><div class=footer-info>2025 ozgurvurgun</div></footer><script>feather.replace()</script><script src=https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js></script>
<script>const keyInput=document.getElementById("key"),contentEl=document.getElementById("content"),encryptedText=contentEl.textContent.trim();keyInput.addEventListener("input",()=>{const e=keyInput.value.trim();if(!e){contentEl.textContent=encryptedText;return}try{const n=CryptoJS.AES.decrypt(encryptedText,e),t=n.toString(CryptoJS.enc.Utf8);if(!t)throw new Error("Çözülemedi");contentEl.textContent=t}catch{contentEl.textContent=encryptedText}})</script></div></body></html>