<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>@ozgurvurgun | NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Modüller Arası İletişim Neden Önemlidir? Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.
Örneğin:
Kullanıcı kaydı yapılınca log&rsquo;a bir şey yazmak isteyebilirsin. Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin. Yani modüllerin birbiriyle konuşması gerekir.
NestJS bunu imports, exports ve dependency injection sistemleriyle sağlar.
Temel Kurgu: Service Kullanmak Senaryomuz şu:
UserService adında bir servisimiz var (UserModule içinde) AuthModule bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için) Şöyle bir şey yapmak istiyoruz:"><meta property="og:image" content><meta property="og:title" content="NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)"><meta property="og:description" content="Modüller Arası İletişim Neden Önemlidir? Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.
Örneğin:
Kullanıcı kaydı yapılınca log&rsquo;a bir şey yazmak isteyebilirsin. Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin. Yani modüllerin birbiriyle konuşması gerekir.
NestJS bunu imports, exports ve dependency injection sistemleriyle sağlar.
Temel Kurgu: Service Kullanmak Senaryomuz şu:
UserService adında bir servisimiz var (UserModule içinde) AuthModule bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için) Şöyle bir şey yapmak istiyoruz:"><meta property="og:type" content="article"><meta property="og:url" content="https://ozgurvurgun.github.io/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/"><meta property="article:section" content="nestJS"><meta property="article:published_time" content="2025-07-29T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)"><meta name=twitter:description content="Modüller Arası İletişim Neden Önemlidir? Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.
Örneğin:
Kullanıcı kaydı yapılınca log&rsquo;a bir şey yazmak isteyebilirsin. Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin. Yani modüllerin birbiriyle konuşması gerekir.
NestJS bunu imports, exports ve dependency injection sistemleriyle sağlar.
Temel Kurgu: Service Kullanmak Senaryomuz şu:
UserService adında bir servisimiz var (UserModule içinde) AuthModule bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için) Şöyle bir şey yapmak istiyoruz:"><script src=https://ozgurvurgun.github.io/js/feather.min.js></script>
<link href=https://ozgurvurgun.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://ozgurvurgun.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://ozgurvurgun.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css media="(prefers-color-scheme: dark)"><style>input[type=text],input[type=password]{font-size:16px!important;touch-action:manipulation}</style></head><body><div class=content><header><div class=main><a href=https://ozgurvurgun.github.io/>@ozgurvurgun</a></div><nav><a href=/>main</a>
<a href=/shorts>shorts</a>
<a href=/projects>projects</a>
<a href=/angular>angular</a>
<a href=/nestjs>nestJS</a>
<a href=/links>links</a>
<a href=/about>me</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)</h1><div class=meta>Posted on Jul 29, 2025</div></div><section class=body><h2 id=modüller-arası-iletişim-neden-önemlidir>Modüller Arası İletişim Neden Önemlidir?</h2><p>Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.</p><p>Örneğin:</p><ul><li>Kullanıcı kaydı yapılınca log&rsquo;a bir şey yazmak isteyebilirsin.</li><li>Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin.</li></ul><p>Yani modüllerin birbiriyle konuşması gerekir.<br>NestJS bunu <code>imports</code>, <code>exports</code> ve dependency injection sistemleriyle sağlar.</p><h2 id=temel-kurgu-service-kullanmak>Temel Kurgu: Service Kullanmak</h2><p>Senaryomuz şu:</p><ul><li><code>UserService</code> adında bir servisimiz var (<code>UserModule</code> içinde)</li><li><code>AuthModule</code> bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için)</li></ul><p>Şöyle bir şey yapmak istiyoruz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// auth.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>userService</span>: <span style=color:#66d9ef>UserService</span>) {}
</span></span></code></pre></div><p>Ama bu çalışmaz. Çünkü NestJS, bir modülde tanımlı provider&rsquo;ı başka modüllere otomatik olarak açmaz.</p><h2 id=ne-yapmam-lazım>Ne Yapmam Lazım?</h2><p>Adım adım gidelim:</p><ol><li>Kullanmak istediğin servisi export et:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserService</span>],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exports</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserService</span>],  <span style=color:#75715e>// dışa açıyoruz
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {}
</span></span></code></pre></div><ol start=2><li>Kullanan modülde, ilgili modülü import et:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// auth.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imports</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserModule</span>],  <span style=color:#75715e>// içeri alıyoruz
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>AuthService</span>],
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthModule</span> {}
</span></span></code></pre></div><ol start=3><li>Artık kullanabilirsin:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// auth.service.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>private</span> <span style=color:#a6e22e>userService</span>: <span style=color:#66d9ef>UserService</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bitti.</p><h2 id=analoji>Analoji</h2><p>Bunu bir ofis binası gibi düşün:</p><ul><li>Her modül bir departman</li><li><code>UserService</code> -> İnsan Kaynakları&rsquo;nda çalışan biri</li><li><code>AuthModule</code> -> Güvenlik departmanı</li></ul><p>Eğer HR&rsquo;dan bir personeli kullanmak istiyorsan:</p><ol><li>HR onu dış dünyaya “tanıtmalı” (export)</li><li>Güvenlik birimi HR ile “protokol imzalamalı” (import)</li><li>Ancak o zaman o kişiyi çağırıp iş yaptırabilirsin</li></ol><h2 id=circular-dependency-sorunu-kabus>Circular Dependency Sorunu (Kabus)</h2><p>Şimdi işler karışıyor.
Diyelim ki hem <code>AuthService</code>, <code>UserService</code>’i kullanıyor… Hem de <code>UserService</code>, <code>AuthService</code>’i çağırmak istiyor.</p><p>Yani:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>UserService → AuthService  
</span></span><span style=display:flex><span>AuthService → UserService
</span></span></code></pre></div><p>Bu bir circular dependency’dir. NestJS bunu görünce error verir:</p><blockquote><p>Cannot resolve dependencies of the UserService</p></blockquote><h2 id=çözüm-forwardref>Çözüm: forwardRef</h2><p>Bu durumda forwardRef kullanmamız gerekir.
Bu, Nest’e “şimdilik tanımadığın ama sonra tanıyacağın bir şeyi kullan” demektir.</p><ol><li>Import ederken:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// user.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imports</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>forwardRef</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>AuthModule</span>)],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserService</span>],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exports</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>UserService</span>],
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserModule</span> {}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// auth.module.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>@Module</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>imports</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>forwardRef</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>UserModule</span>)],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>AuthService</span>],
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthModule</span> {}
</span></span></code></pre></div><ol start=2><li>Inject ederken de <code>@Inject(forwardRef(...))</code>:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>@Injectable</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserService</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@Inject</span>(<span style=color:#a6e22e>forwardRef</span>(() <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>AuthService</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>authService</span>: <span style=color:#66d9ef>AuthService</span>,
</span></span><span style=display:flex><span>  ) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Bu yapı ilk bakışta karışık gibi ama büyük projelerde olmazsa olmaz bir tekniktir.</p></blockquote><h2 id=ipucu-exports-sadece-providerlar-içindir>İpucu: exports sadece provider’lar içindir</h2><p><code>exports: [X]</code> dediğinde sadece servisleri (provider) paylaşabilirsin. Controller’lar dışa açılmaz, onlar sadece istek karşılar. Ayrıca <code>controllers: []</code> ve <code>providers: []</code> bir yere export edilmezse sadece o modülde erişilebilir olur.</p><h2 id=eksikkritik-nokta-karmaşık-yapılarda-iz-sürmek-zorlaşabilir>Eksik/Kritik Nokta: Karmaşık Yapılarda İz Sürmek Zorlaşabilir</h2><p>Evet, bu sistem sağlam. Ama şunu da kabul edelim:</p><ul><li>Bir modül birden fazla yere import/export edilince neyin nereden geldiğini takip etmek zorlaşabiliyor.</li><li>Circular dependency durumları projeyi kırabilir.</li><li>forwardRef, çözüm getiriyor ama yapıyı daha karmaşıklaştırıyor.</li><li>Export ettiğin bir servisi iki farklı modülde override etmeye çalışırsan kontrol sende olmayabilir.</li></ul><blockquote><p>Yani bu güçlü yapı, “iyi bir mimari disiplin” ile desteklenmezse başına bela olabilir.</p></blockquote></section><div class=post-tags></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/ozgurvurgun rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://linkedin.com/in/ozgurvurgun1 rel=me title=Linkedin><i data-feather=linkedin></i></a>
<a class=border></a><a class=soc href=http://emre.xyz/me.vcf rel=me title=VCF><i data-feather=phone></i></a>
<a class=border></a><a class=soc href=http://emre.xyz/resume.pdf rel=me title=Resume><i data-feather=file-text></i></a>
<a class=border></a></div><div class=footer-info>2025 ozgurvurgun</div></footer><script>feather.replace()</script><script src=https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js></script>
<script>const keyInput=document.getElementById("key"),contentEl=document.getElementById("content"),encryptedText=contentEl.textContent.trim();keyInput.addEventListener("input",()=>{const e=keyInput.value.trim();if(!e){contentEl.textContent=encryptedText;return}try{const n=CryptoJS.AES.decrypt(encryptedText,e),t=n.toString(CryptoJS.enc.Utf8);if(!t)throw new Error("Çözülemedi");contentEl.textContent=t}catch{contentEl.textContent=encryptedText}})</script></div></body></html>