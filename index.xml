<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>@ozgurvurgun</title><link>https://ozgurvurgun.github.io/</link><description>Recent content on @ozgurvurgun</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>ozgurvurgun</copyright><lastBuildDate>Thu, 31 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ozgurvurgun.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Giriş Temel Bİlgiler</title><link>https://ozgurvurgun.github.io/nestjs/1-what-is-nestjs/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/1-what-is-nestjs/</guid><description>NestJS&amp;rsquo;e Giriş: Neden Yeni Bir Şeye Daha İhtiyacımız Var? Node.js harika. JavaScript&amp;rsquo;in gücünü sunucu tarafına taşıdı, “Aynı dili hem frontend&amp;rsquo;de hem backend&amp;rsquo;de kullanma” rüyasını gerçeğe dönüştürdü. Ama ne zaman ki işler büyüdü, bu özgürlük başımıza bela olmaya başladı. Çünkü:
Herkes her şeyi her yerde yapabiliyordu. Proje büyüdükçe dosyalar çöplüğe dönebiliyordu. Kod tekrarları, karışık business logic, zor test edilebilir yapılar ortaya çıkıyordu. İşte NestJS burada sahneye çıkıyor.
NestJS Nedir? NestJS, TypeScript ile yazılmış, modüler bir backend framework&amp;rsquo;üdür.</description></item><item><title>What is Angular</title><link>https://ozgurvurgun.github.io/angular/1-what-is-angular/</link><pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/1-what-is-angular/</guid><description>Angular&amp;rsquo;ın Felsefesi ve Paradigması Angular bir &amp;ldquo;framework&amp;quot;tür, bir &amp;ldquo;library&amp;rdquo; değil. Bu şu anlama gelir:
Ne yapman gerektiğini değil, nasıl yapman gerektiğini söyler. Bir yapı ve düzen silsilesi sunar. Geliştirici özgürlüğünü azaltır ama büyük ölçekli projelerde tutarlılık, test edilebilirlik ve bakım kolaylığı sağlar. Paradigması Component-Based Architecture (React ile benzer) Declarative Template Syntax (HTML içinde Angular&amp;rsquo;ın syntax&amp;rsquo;ı kullanılabilir, bildiğin template engine işte) Two-Way Data Binding (Kısaca UI ile JS arasına kablo çekmişler, değişkende bir değişiklik olunca anında UI değişiyor; aynı şekilde UI’da bir değişiklik olunca değişken güncelleniyor gibi bir şey) Dependency Injection (Bağımlılık sokuşturma) RxJS ile Reactive Programming (Kısaca bir veri kaynağında bir değişiklik olunca bu otomatik bir zincirleme reaksiyonu tetikliyor, bir şeyler yapılıyor.</description></item><item><title>İlk NestJS Uygulaması</title><link>https://ozgurvurgun.github.io/nestjs/2-ilk-nestjs-uygulamasi/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/2-ilk-nestjs-uygulamasi/</guid><description>NestJS Projesine İlk Adım Artık teoriyi kenara bırakıp işe girişme zamanı. Bu yazıda, sıfırdan bir NestJS projesi oluşturup çalıştıracağız. “Hello World” endpoint’imizi yazacak, klasörleri tanıyacak, ve uygulamanın yaşam döngüsünü anlayacağız.
Amaç: NestJS&amp;rsquo;e dair temel taşları yerine oturtmak. Ezberlemeden, sindirerek ilerlemek.
1. NestJS CLI ile Proje Oluşturma NestJS, Angular&amp;rsquo;dan esinlenmiş bir yapı sunduğu için, benzer şekilde bir CLI (Command Line Interface) aracı sunar.
Kurulum:
npm i -g @nestjs/cli Yeni proje oluştur:</description></item><item><title>Initially</title><link>https://ozgurvurgun.github.io/angular/2-initially/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/2-initially/</guid><description> Angular CLI NodeJs üzerinde çalışır öncelikle NodeJs kurmalı.
npm install -g @angular/cli cd ~/Projects # or... ng new my-app Bir kaç soru soracak sistem tasarımına göre bunlara cevap ver.
ng serve --port 4200 Hayırlı olsun Angular ayağa kalkmış olmalı. Angular CLI komutları hakkında bilgi almak istersen ng help komutunu kullan.</description></item><item><title>NestJS Mimarisi: Modüller ve Temel Kavramlar (1. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/3-nestjs-mimarisi-temel-kavramlar-1/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/3-nestjs-mimarisi-temel-kavramlar-1/</guid><description>Neden Modül? Küçük projelerde her şeyi tek dosyada yazmak kolaydır. Ama işler büyüyünce işler sarpa sarar. Kod karmaşıklaşır, neyin nerede olduğunu bulmak zorlaşır. İşte burada modüller devreye girer.
NestJS, Angular&amp;rsquo;dan aldığı ilhamla “her şey bir modülün içinde” prensibiyle çalışır.
Bir modül, belirli bir işlevi yerine getiren yapıları gruplar: controller&amp;rsquo;lar, service&amp;rsquo;ler, provider&amp;rsquo;lar&amp;hellip;
1. Modül Nedir? NestJS’te her yapı bir modülün içinde yaşar.
Modül; bağımsız, izole, bir iş parçasını temsil eden bir yapıdır.</description></item><item><title>First Component</title><link>https://ozgurvurgun.github.io/angular/3-first-component/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/3-first-component/</guid><description>Angular ile yeni bir component oluşturmak için şu komutu verirsin
ng generate component first or
ng g c first bu kadar :)</description></item><item><title>NestJS Mimarisi: Modüller Arası İletişim (2. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/4-nestjs-mimarisi-temel-kavramlar-2/</guid><description>Modüller Arası İletişim Neden Önemlidir? Modülleri ayırdık ama gerçek hayatta işler böyle izole ilerlemez.
Örneğin:
Kullanıcı kaydı yapılınca log&amp;rsquo;a bir şey yazmak isteyebilirsin. Bir ödeme alınınca stok sistemini bilgilendirmek isteyebilirsin. Yani modüllerin birbiriyle konuşması gerekir.
NestJS bunu imports, exports ve dependency injection sistemleriyle sağlar.
Temel Kurgu: Service Kullanmak Senaryomuz şu:
UserService adında bir servisimiz var (UserModule içinde) AuthModule bu servisi kullanmak istiyor (örneğin kullanıcıyı veritabanında sorgulamak için) Şöyle bir şey yapmak istiyoruz:</description></item><item><title>Directive</title><link>https://ozgurvurgun.github.io/angular/4-directive/</link><pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/4-directive/</guid><description>Bir düşünelim: HTML temelde birr takım verinin semantik şekilde gösterilemsinden ibaret. Bir noktada bu statik yapıya takla attrmak istiyorsun. &amp;ldquo;Bu elementi sadece bazı durumlarda göster&amp;rdquo;, &amp;ldquo;Şuna tıklandığında şu davranış tetiklensin&amp;rdquo;, &amp;ldquo;Şu div&amp;rsquo;i mavi yap ama bazı senaryolarda yeşil olsun&amp;rdquo; falan diyorsun.
Bir noktada bu davranışların soyutlanması icap ediyor. Yani sadece ne göreceğini değil, nasıl davranacağını da kontrol etmek istiyorsun.
Bu meta programlama dediğimiz yaklaşımın ilk adımıdır:
&amp;ldquo;Kodu kodla şekillendirme işi&amp;rdquo;</description></item><item><title>NestJS Mimarisi: Dinamik Modüller ve Yapılandırma (3. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/5-nestjs-mimarisi-temel-kavramlar-3/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/5-nestjs-mimarisi-temel-kavramlar-3/</guid><description>Dinamik Modül Nedir? Normal modüller sabittir. İçine neyi yazdıysan, sistem onu kullanır.
Ama bazen bir modülün kurulum aşamasında parametre alması gerekir.
Yani modülün davranışı dışarıdan gelen bir yapılandırmaya göre değişmelidir.
İşte burada dinamik modül devreye girer.
Gerçek Hayat Senaryosu Diyelim ki bir MailerModule yazıyorsun.
Geliştirme ortamında log’a yazmasını, Gerçek ortamda ise SMTP sunucusuna mail atmasını istiyorsun. Yani modül şunu demeli:
“Ben dışarıdan bana nasıl davranacağım söylensin istiyorum.”
Nasıl Tanımlanır? Dinamik modül, static register() veya static registerAsync() metotlarıyla tanımlanır.</description></item><item><title>Service</title><link>https://ozgurvurgun.github.io/angular/5-service/</link><pubDate>Thu, 17 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/5-service/</guid><description>Angular Service Nedir? Angular Service dediğimiz şey, uygulamada ortaklaşa kullanılan işleri ve verileri tek bir yerde toplayan TypeScript sınıflarıdır. Misal:
API&amp;rsquo;den veri çekmek Bileşenler arasında veri paylaşmak Ortak bir hesaplama, filtreleme, validasyon işlemini yapmak gibi işler için service yazarsın. Böylece aynı kodu her component’te yeniden yazmazsın.
Ne Diye Service Denen Zımbırtıları Kullanıyoruz? Bir örnek: Hem AComponent hem BComponent aynı veriyi kullanmak istiyor. Gidip her birine ayrı ayrı veri koyarsan kopukluk olur.</description></item><item><title>NestJS Mimarisi: Global Modüller ve Kullanım Senaryoları (4. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/6-nestjs-mimarisi-temel-kavramlar-4/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/6-nestjs-mimarisi-temel-kavramlar-4/</guid><description>Global Modül Nedir? NestJS&amp;rsquo;te bir modül normalde sadece import edildiği yerde kullanılır.
Yani UserModule içinde tanımlı bir UserService, sadece onu import eden modüller tarafından erişilebilir.
Ama bazı modüller vardır ki:
“Beni her yerden erişilebilir yap” demek ister.
İşte bu tür modüller için global modül kavramı vardır.
Nasıl Tanımlanır? Bir modülü global yapmak için @Global() dekoratörünü kullanırız.
// logger.module.ts @Global() @Module({ providers: [LoggerService], exports: [LoggerService], }) export class LoggerModule {} Artık bu modülü AppModule&amp;lsquo;de bir kez import etmek yeterlidir:</description></item><item><title>Pipe</title><link>https://ozgurvurgun.github.io/angular/6-pipe/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/6-pipe/</guid><description>Pİie Nedir? Neden Vardır? Şöyle düşün: Bir değerin ham hali ile gösterilecek hali genellikle aynı değildir.
Tarih formatı farklı gösterilsin istersin. Sayının sonuna TL, $ gibi birim gelsin istersin. Tüm harfleri büyük/küçük yapmak istersin. listeyi filtrelemek, slice etmek istersin. Bunların hepsini component içinde yapmak mümkün. Ama zamanla kod şişer, tekrar eder, okunmaz hale gelir.
Angular burada şöyle der:
Veri değişmeyecek. Sadece görüntüsü değişecekse, o zaman bunu HTML&amp;rsquo; de hallet.
Bu yaklaşımın adı: Pipe</description></item><item><title>NestJS Mimarisi: Controller Nedir? Ne Değildir? (5. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/7-nestjs-mimarisi-temel-kavramlar-5/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/7-nestjs-mimarisi-temel-kavramlar-5/</guid><description>Controller Nedir? NestJS&amp;rsquo;te Controller, gelen HTTP isteklerini karşılayan yapıdır.
Yani dış dünyadan gelen tüm GET, POST, PUT, DELETE istekleri burada karşılanır.
Kısaca: Controller = API’nin giriş noktasıdır.
Router mı bu? Express kullanmış olanlar için şöyle bir benzetme yapalım:
// Express app.get(&amp;#39;/users&amp;#39;, handler); // NestJS @Controller(&amp;#39;users&amp;#39;) export class UserController { @Get() getAll() { return &amp;#39;user listesi&amp;#39;; } } Arka planda aslında Express (veya Fastify) hala çalışıyor. Ama NestJS bunu sınıflar ve dekoratörlerle daha okunabilir ve organize bir hâle getiriyor.</description></item><item><title>Guard</title><link>https://ozgurvurgun.github.io/angular/7-guard/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/7-guard/</guid><description>Guard Nedir? Neden Var? Şöyle düşün:
Bir apartman giriş kapısı var ama herkese açık değil. Kapıda bir güvenlik görevlisi var ve sana sorular soruyor:
Kimsin? Giriş iznin var mı? Bu kata çıkabilir misin? Bu daireye özel yetkin var mı? İşte bu Angular Gaurd tam olarak bu işi yapar. Uygulamanın rotaları arasında geçiş yapılırken kim geçebilir, kim geçemez sorularına cevap verir.
Guard Ne İş Yapar? Angular&amp;rsquo;daki Router sistemi sayesinde sayfalar arasında geziniriz (/login, /dashboard, /admin vs).</description></item><item><title>NestJS Mimarisi: Controller’da Request ve Response Nesnelerinin Kullanımı (6. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/8-nestjs-mimarisi-temel-kavramlar-6/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/8-nestjs-mimarisi-temel-kavramlar-6/</guid><description>NestJS’te Request ve Response Nesneleri NestJS, altında Express (veya Fastify) kullanır.
Yani istersen alışılagelmiş req, res nesnelerine erişebilirsin.
Ama NestJS bunun yerine decorator temelli bir yaklaşım sunar.
Yani doğrudan req.body yerine @Body() kullanırsın.
res.send() yerine doğrudan return yaparsın.
Peki nasıl ve neden?
@Req() ve @Res() Nedir? @Req(): HTTP isteğini temsil eden Request objesini verir. (Express tipindedir)
@Get() handleRequest(@Req() req: Request) { console.log(req.headers[&amp;#39;user-agent&amp;#39;]); return &amp;#39;Gelen istek işlendi&amp;#39;; } @Res(): Manuel olarak yanıt oluşturmak istediğinde kullanılır.</description></item><item><title>Componentler Arası Veri Akışı</title><link>https://ozgurvurgun.github.io/angular/8-componentler-arasi-veri-akisi/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/8-componentler-arasi-veri-akisi/</guid><description>Angular&amp;rsquo;da Bileşenler Konuşur mu? Bileşenlerinizi oluşturuyorsunuz:
AppComponent NavbarComponent UserCardComponent TodoListComponent Ama bir sorun var: Bunlar yalnızca görüntü mü veriyor, yoska birbirleriyle konuşabiliyorlar mı? Cevap: Evet konuşabilirler. Ama sadece belirli yollarla.
Angular&amp;rsquo;ın Felsefesi: Tek Yönlü Veri Akışı Angular&amp;rsquo;da veri akışı: Parent ➡️ Child
Yani üst bileşen, alt bileşene veri gönderir. Tersini yapmak istersen, child bileşen sadece bir event fırlatabilir.
&amp;ldquo;Benim içimde bir şey oldu, haberin olsun&amp;rdquo; der.
Bu mekanizma için 2 araç kullanırız:</description></item><item><title>NestJS Mimarisi: Status Code Yönetimi (7. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/9-nestjs-mimarisi-temel-kavramlar-7/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/9-nestjs-mimarisi-temel-kavramlar-7/</guid><description>HTTP Status Code Nedir? Neden Önemlidir? Bir API sadece veri döndürmez.
Her cevabın bir anlamı olmalıdır. Bu anlamı taşıyan şey de status code&amp;rsquo;tur.
return { message: &amp;#39;Başarılı!&amp;#39; }; Bu cevap 200 OK ile gelir mi? 201 Created mi? Yoksa 400 Bad Request mi? İşte bu çok kritik. Çünkü:
Status code = İstemciye ne olduğunu anlatan işaret lambasıdır.
NestJS’te Status Code Nasıl Yönetilir? En sade yol: @HttpCode() dekoratörüdür.
@Post() @HttpCode(201) createUser() { return { message: &amp;#39;Kullanıcı oluşturuldu&amp;#39; }; } Bu örnekte POST /users isteğine dönüş 201 Created olacaktır.</description></item><item><title>Service Injection ve Dependency Injection (DI) felsefesi</title><link>https://ozgurvurgun.github.io/angular/9-service-injection-ve-dependency-injection-felsefesi/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/9-service-injection-ve-dependency-injection-felsefesi/</guid><description>Neden Kodu Parçalamak Yetmez? Diyelim ki bir bileşen, API&amp;rsquo;den veri çekiyor:
export class UserComponent { constructor() { fetch(&amp;#39;https://api.example.com/users&amp;#39;) .then(res =&amp;gt; res.json()) .then(data =&amp;gt; this.users = data); } } Çalışıyor mu? Evet.
Ama test edilebilir mi? Hayır. Başka yerde tekrar kullanılabilir mi? Hayır. API değişirse ne olacak? Her yeri mi değiştireceğiz? Evet. Yani: felaket. İşte bu yüzden yazılım mühendisi emmiler şöyle der:
Bileşenler ihtiyaçlarını kendi üretmemeli, dışarıdan almalı.
Dependency Injection Nedir? Dependency Injection, bir sınıfın ihtiyaç duyduğu şeyleri (servis, veri, yapı) kendi içinde üretmek yerine, dışarıdan alması prensibidir.</description></item><item><title>NestJS Mimarisi: Global Exception Handle (8. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/10-nestjs-mimarisi-temel-kavramlar-8/</link><pubDate>Wed, 30 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/10-nestjs-mimarisi-temel-kavramlar-8/</guid><description>Hata Fırlatmak Yetmez, Yakalamak da Gerekir Hatalar kaçınılmaz. Ama kontrolsüz hata = üretimde patlayan sistem = sinirli müşteri = uykusuz geliştirici.
NestJS bu durumu çözmek için merkezî bir hata yakalama mekanizması sunar: Global Exception Filter
Şimdiye Kadar Ne Yaptık? Şöyle kodlar yazdık:
if (!userExists(id)) { throw new NotFoundException(&amp;#39;Kullanıcı bulunamadı&amp;#39;); } Ve Nest bunu alıp güzelce 404 yanıtıyla döndü. Harika.
Ama ya özel bir hata sınıfı yazmak istiyorsan? Ya da her hatayı { status, errorCode, message, timestamp } gibi özel bir formatta döndürmek istiyorsan?</description></item><item><title>Angular’da API İstekleri ve HttpClient Kullanımı</title><link>https://ozgurvurgun.github.io/angular/10-angularda-api-istekleri-ve-httpclient-kullanimi/</link><pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/10-angularda-api-istekleri-ve-httpclient-kullanimi/</guid><description>Angular&amp;rsquo;da API ile Konuşmak: HttpClient Bir frontend uygulaması coğu zaman tek başına bir frontend değildir. Backend ile konuşur, veri çeker, gönderir, günceller.
Angular&amp;rsquo;da bu işi yapmak için HttpClient servisi kullanılır.
Angular&amp;rsquo;da HTTP demek, HttpCLient demektir.
HttpClient Nedir? Angular bize @angular/common/http paketiyle gelen HttpClient sınıfını sunar.
Bununla şunları yapabilirsin:
GET, POST, PUT, DELETE, gibi HTTP istekleri atmak Header, query param, body gibi seçenekler eklemek RxJS sayesinde asenkron istekleri yönetmek Interceptor&amp;rsquo; larla istek öncesi/sonrası işlemler eklemek Ama önce HttpClientModule&amp;rsquo; ü app module&amp;rsquo;e dahil etmelisin:</description></item><item><title>NestJS Mimarisi: Headers ve Query Parametreleri Okuma (9. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/11-nestjs-mimarisi-temel-kavramlar-9/</link><pubDate>Wed, 30 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/11-nestjs-mimarisi-temel-kavramlar-9/</guid><description>HTTP İsteği Sadece Body&amp;rsquo;den İbaret Değil API’ye gelen her istek 3 temel veri kaynağı taşır:
Body -&amp;gt; İçerik, payload Query -&amp;gt; Filtre, arama, sayfalama gibi şeyler Headers -&amp;gt; Kimlik, token, dil bilgisi, içerik türü Ve bunların her biri farklı ihtiyaçlara hizmet eder. NestJS bu üçüne de ayrı dekoratörler sunar.
Bu bölümde @Query() ve @Headers() üzerinde duracağız.
@Query() - Sorgu Parametrelerini Okumak
Örnek URL:
GET /products?page=2&amp;amp;limit=10&amp;amp;sort=price Bu URL&amp;rsquo;deki page, limit ve sort kısmı query parametresidir.</description></item><item><title>Angular Forms – Template vs Reactive</title><link>https://ozgurvurgun.github.io/angular/11-angular-forms-template-vs-reactive/</link><pubDate>Fri, 25 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/11-angular-forms-template-vs-reactive/</guid><description>Giriş: Form Nedir? Sadece Input mu? Form = Kullanıcıdan veri almak. Ama sadece &amp;lt;input /&amp;gt; koymakla iş bitmez. İhtiyacın olan şey:
Validasyon (giriş kontrolü) Veri toplama Dinamik alanlar (birden fazla e-posta vs.) Submit işlemi Temizleme, resetleme Form state takibi (dirty, touched, valid&amp;hellip;) İşte Angular burada iki yol sunar: Template-Driven ve Reactive Forms
Angular’ın Bakışı: “Form bir bileşen değil, bir state’tir.” Bir input&amp;rsquo;a sadece veri bağlamazsın.
Değeri ne? Değişti mi? Hata var mı?</description></item><item><title>NestJS Mimarisi: Route Wildcard ve Prefixler (10. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/12-nestjs-mimarisi-temel-kavramlar-10/</link><pubDate>Wed, 30 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/12-nestjs-mimarisi-temel-kavramlar-10/</guid><description>Rota Yönetiminde Bir Seviye Yukarı: Wildcard ve Prefix Kullanımı Normalde rotaları şöyle tanımlarız:
@Controller(&amp;#39;users&amp;#39;) export class UserController { @Get() getAll() { ... } @Get(&amp;#39;:id&amp;#39;) getById(@Param(&amp;#39;id&amp;#39;) id: string) { ... } } Ama bazı durumlarda daha esnek tanımlamalar gerekebilir:
Tüm istekleri karşılayan bir “catch-all” route Belirli bir grup route’a ön ek tanımlama Statik dosyalar, client-side SPA fallback gibi durumlar İşte burada wildcard ve prefix kavramları devreye giriyor.
1. Route Prefix Nedir? Prefix, bir grup route’un başına otomatik olarak eklenen ortak path’tir.</description></item><item><title>RxJS ve Angular’da Reaktif Programlama</title><link>https://ozgurvurgun.github.io/angular/12-rxjs-ve-angularda-reaktif-programlama/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/12-rxjs-ve-angularda-reaktif-programlama/</guid><description>Reaktif programlama Nedir? Şöyle düşün:
Bir şey değiştiğinde, başka bir şey otomatik değişsin istiyorum
Bu fikir temel olarak reaklam panosuna benzer. Panoya fiyatı asarsın, her yerde o fiyat görünür. Ama panoya yeni fiyatı yazdığında tüm afişler otomatik güncellenir.
Buna veri akışına tepki verme yani reaktif olma denir.
RxJS Nedir? RxJS, &amp;ldquo;Reactive Extensions for JavaSript&amp;rdquo; anlamına gelir. Yani: &amp;ldquo;JavaScript&amp;rsquo;e reaktif yetenek ekleyelim&amp;rdquo; projesidir.
Angular, fromdan HTTP&amp;rsquo;ye router&amp;rsquo;dan event&amp;rsquo;lere kadar her şeyi Observable sistemiyle yönetir.</description></item><item><title>NestJS Mimarisi: Provider Nedir? Ne Sağlar? (11. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/13-nestjs-mimarisi-temel-kavramlar-11/</link><pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/13-nestjs-mimarisi-temel-kavramlar-11/</guid><description>NestJS’te Her Şey Bir Provider’dır NestJS&amp;rsquo;te controller, service, guard, pipe, hatta resolver&amp;hellip; Bunların hepsi özünde birer provider&amp;rsquo;dır.
Provider = Nest container’ına tanıtılan ve başka yerlerden inject edilebilen bir “şey”dir.
Sen bir service yazarsın, onu @Injectable() yaparsın - bu, Nest’e şunu demektir:
&amp;ldquo;Bunu bir yerde kullanmak isteyeceğim, lütfen enjekte edilebilir hale getir.&amp;rdquo;
En Temel Kullanım: Servis Olarak Provider @Injectable() export class UserService { findAll() { return [&amp;#39;Ali&amp;#39;, &amp;#39;Ayşe&amp;#39;]; } } Bu sınıf bir provider olur.</description></item><item><title>Lazy Loading</title><link>https://ozgurvurgun.github.io/angular/13-lazy-loading/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/13-lazy-loading/</guid><description>Lazy Loading Nedir? Lazy Loading, Türkçesiyle tembel yükleme, uygulamamızdaki bazı modülleri ilk başta yüklememek, sadece ihtiyaç duyulduğunda (örn. bir route ziyaret edildiğinde) yüklemek demektir.
Ana fikir:
“Her şeyi başta yükleme, kullanıcı neye tıklarsa onu getir.”
Neden Lazy Loading? Angular projeleri büyüdükçe, bundle (paket) boyutu artar. Bu neye yol açar?
İlk yükleme süresi uzar Kullanıcı daha uygulamayı görmeden bile MB’larca veri iner Özellikle mobil kullanıcılar için felaket olabilir Lazy Loading buna çare olur:</description></item><item><title>NestJS Mimarisi: Service Oluşturma ve Kullanma (12. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/14-nestjs-mimarisi-temel-kavramlar-12/</link><pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/14-nestjs-mimarisi-temel-kavramlar-12/</guid><description>Controller İş Yapar, Service İşletir NestJS mimarisinde Controller, dış dünyayla konuşan yerdir. Ama işin mantığı, hesaplama, veri işleme gibi şeyler Service içinde olmalıdır.
Controller = sekreter. Çağrıyı alır, ilgili departmana yönlendirir. Service = departman. Gerçek işi yapar.
Eğer her şeyi controller içinde yaparsan:
Test yazmak zorlaşır Kod tekrar eder Modülerlik kaybolur API karmaşıklaşır Service Tanımlamak: En Temel Hali @Injectable() export class UserService { private users = [&amp;#39;Ayşe&amp;#39;, &amp;#39;Fatma&amp;#39;, &amp;#39;Hayriye&amp;#39;]; findAll() { return this.</description></item><item><title>Signals</title><link>https://ozgurvurgun.github.io/angular/14-signals/</link><pubDate>Sat, 26 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/14-signals/</guid><description>Angular Signals - Yeni Nesil Reaktivite Neden Böyle Bir Yapıya İhtiyaç Duyuldu?
Angular uzun yıllardır reaktif programlama ihtiyaçlarını karşılamak için RxJS kütüphanesini kullanıyordu. Observable Subject pipe map switchMap subscribe unsubscribe gibi yapılar bu sistemin parçalarıydı.
Ancak bu yapı:
Öğrenilmesi karmaşık Hatalara açık Basit senaryolarda gereksiz yere ağır hale gelebiliyordu. Angular ekibi bu sebeple daha basit, daha doğal, daha az kodla daha çok şey yapılabilen bir yapı üzerinde çalıştı. Ve Signal ortaya çıktı.</description></item><item><title>NestJS Mimarisi: Business Logic Katmanı Olarak Servisler (13. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/15-nestjs-mimarisi-temel-kavramlar-13/</link><pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/15-nestjs-mimarisi-temel-kavramlar-13/</guid><description>&amp;ldquo;Business Logic&amp;rdquo; Ne Demek? Kodda her şey teknik olmak zorunda değil. Bir de işin iş tarafı (business) var.
Kullanıcı kayıt olurken e-posta eşsiz olmalı
Bir ürün stoğu sıfırsa sepete eklenememeli
Hafta sonu sipariş geçersiz sayılmalı
Bunlar framework’le değil, iş modeliyle ilgili kurallardır. Ve işte bunlara business logic denir.
Peki Bu Kurallar Nereye Yazılır? Controller’a yazarsan: Kodun şişer. Test yazmak eziyet olur. Entity’ye yazarsan: Veritabanına fazla sorumluluk yüklersin. Pipe’a yazarsan: Genellikle sadece doğrulama yapılır.</description></item><item><title>angular.json</title><link>https://ozgurvurgun.github.io/angular/15-angular.json/</link><pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/15-angular.json/</guid><description>Bu Dosya Nedir? angular.json, bir Angular projesinin yapılandırma dosyasıdır. Angular CLI, bu dosyaya bakarak:
Projenin nerede başladığını Hangi derleyici ayarlarının kullanılacağını Build, test, lint, serve komutlarında ne yapılacağını Uygulama yollarını, stilleri, scriptleri gibi yüzlerce detayı öğrenir ve uygular.
Bu dosya olmadan Angular CLI, projeyi nasıl çalıştıracağını bilemez.
angular.json Nerede Bulunur? Her Angular projesinde, projenin kök dizininde bulunur:
/app ├── src/ ├── angular.json ├── package.json ├── tsconfig.json angular.json’un Genel Yapısı { &amp;#34;$schema&amp;#34;: &amp;#34;.</description></item><item><title>NestJS Mimarisi: Value, Class ve Factory Providers (14. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/16-nestjs-mimarisi-temel-kavramlar-14/</link><pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/16-nestjs-mimarisi-temel-kavramlar-14/</guid><description>Provider Ne Demekti? NestJS’de bir class veya değer, &amp;ldquo;provider&amp;rdquo; olarak tanımlanırsa constructor() içinde @Inject() ile enjekte edilebilir.
Yani dependency injection sistemine kayıtlı olur. Ama bu provider illa bir class olmak zorunda değil.
İşte tam burada 3 farklı yol devreye giriyor:
Tür Ne Sağlar? Ne Zaman Kullanılır? Value Provider Sabit bir değer (obj, string, sayı) Config, sabit ayarlar, env verileri Class Provider Alternatif class tanımı Mock servis, farklı implementasyonlar Factory Provider Fonksiyonla üretilen provider Dinamik yapı, config’e bağlı servis üretimi 1.</description></item><item><title>Zoneless Nedir?</title><link>https://ozgurvurgun.github.io/angular/16-zoneless-nedir/</link><pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/16-zoneless-nedir/</guid><description>Angular deyince akla genelde component’ler, service’ler falan gelir ama içerde bir mimari var ki, senin haberin bile olmadan bütün uygulamanın kaderini etkiliyor:
Zone.js Bu yazıda Zone.js nedir, ne iş yapar, neden Angular artık onsuz olmaya çalışıyor ve bu neye çare olabilir… hepsine tek tek gireceğiz.
Zone.js Nedir? Kısaca:
Zone.js, JavaScript&amp;rsquo;teki async olayları izleyen bir kütüphanedir.
Yani sen setTimeout, fetch, Promise, addEventListener falan kullandığında, Angular’ın &amp;ldquo;bir şey oldu galiba&amp;rdquo; deyip yeniden UI güncellemesi yapmasını sağlar.</description></item><item><title>NestJS Mimarisi: Provider Scope (15. Bölüm)</title><link>https://ozgurvurgun.github.io/nestjs/17-nestjs-mimarisi-temel-kavramlar-15/</link><pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/nestjs/17-nestjs-mimarisi-temel-kavramlar-15/</guid><description>Bir Servis, Herkes İçin Aynı mıdır? NestJS’te @Injectable() bir sınıf tanımladığında, varsayılan olarak bu servis singleton olur:
Tüm uygulama boyunca sadece 1 kez oluşturulur ve herkes aynı örneği kullanır.
Ama bu her zaman ideal değildir.
Bazı durumlarda:
Her HTTP isteği için yeni bir örnek gerekebilir (örneğin kullanıcıya özel veri taşımak) Her dependency injection noktası farklı bir örnek almalıdır İşte burada scope kavramı devreye girer.
3 Temel Scope Türü Scope Yaşam Süresi Kullanım Senaryosu SINGLETON Tüm uygulama boyunca 1 örnek Varsayılan, çoğu servis bu olur REQUEST Her HTTP isteği için yeni Kullanıcıya özel veri tutan servisler TRANSIENT Her kullanımda yeni örnek Paylaşılmaması gereken servisler (stateless) 1.</description></item><item><title>Internationalization ve Localization - Angular Çok Dillilik Meselesi</title><link>https://ozgurvurgun.github.io/angular/17-internationalization-localization/</link><pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/17-internationalization-localization/</guid><description>Uygulamanı yazdın, harika çalışıyor. Ama bir gün Product Manager gelip şöyle diyor:
Yani uygulama çok güzel ama&amp;hellip; bunu Almanca da yapabilir miyiz?
Yani &amp;ldquo;Kullanıcıya Giriş Yap değil de Anmelden yazsın.
Senin iç sesin:
Hay aq&amp;hellip; O kadar JSON&amp;rsquo;u kim yazacak, her yere this.text = translations[this.currentLang][&amp;ldquo;blabla&amp;rdquo;]; diye mi koyacağım
Ama korkma dostum, Angular bu konuda çözümler sunmuş.
Önce Temel Kavramları Oturtalım | Terim | Anlamı | | ------------------------------- | -------------------------------------------------------------------- | | Internationalization (i18n) | Uygulamanı çok dilli hale getirme hazırlığıdır.</description></item><item><title>Monorepo Nedir?</title><link>https://ozgurvurgun.github.io/angular/18-monorepo-nedir/</link><pubDate>Sun, 27 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/angular/18-monorepo-nedir/</guid><description>Ne Bu Monorepo? Projeyi yazıyorsun, her şey yolunda. Sonra ekip büyüyor. Frontend bir yerde, backend başka yerde, ortak UI bileşenleri başka bir repo’da&amp;hellip;
Bir noktada kendini şöyle derken buluyorsun:
Abi şu ui-kit’i güncelledim ama 3 farklı repo’da aynı şeyi elle publish’lemek zorundayım
İşte burada Monorepo devreye giriyor.
Monorepo = Tüm projelerini, kütüphanelerini, app’lerini tek bir Git deposunda toplamak.
Tek repo. Tek hayat. Çok huzur (doğru kullanılırsa).
Polyrepo vs Monorepo | Özellik | Polyrepo | Monorepo | | ------------------- | --------------------------- | ------------------------------ | | Kod yapısı | Her proje ayrı repo | Her şey tek repo içinde | | Versiyonlama | Her repo kendi içinde | Ortak versiyon yönetimi | | Ortak kod paylaşımı | Zor, publish gerekebilir | import ile direkt erişim | | CI/CD | Her repo için ayrı pipeline | Ortak config ile yönetilebilir | | Bağımlılık takibi | Dağınık | Merkezi | Ne Zaman Lazım Olur?</description></item><item><title>Category Theory for Programmers - Bartosz Milewski</title><link>https://ozgurvurgun.github.io/posts/category-theory-for-programmers-bartosz-milewski/</link><pubDate>Mon, 28 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/category-theory-for-programmers-bartosz-milewski/</guid><description>Teorik fizikçi, programcı ve matematikçi (adamın olmadığı masa yok lol) Bartosz Milewski&amp;rsquo;nin yazdığı Category Theory for Programmers kitabını okuyorum ve bu blog serisinde bölüm bölüm özetleyeceğim.
Kendi adıma: bağlamdan kolay kopuyorum ve hızlı unutuyorum. Bu yüzden kitabı her 20 sayfalık bloklar halinde okuyarak, anladıklarımı burada toparlayacağım. Böylece hem kendim için kalıcı hale getirmiş olacağım hem de başkalarına faydalı olursa ne mutlu.
Bu yazıda, 20 sayfalık bölümler hâlinde notlarım ve özetlerim yer alacak.</description></item><item><title>JavaScript mi Sandın?</title><link>https://ozgurvurgun.github.io/posts/javascriptmi-sandin/</link><pubDate>Sat, 26 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/javascriptmi-sandin/</guid><description>Şu kodları görmüşsündür:
document.addEventListener(&amp;#34;click&amp;#34;, () =&amp;gt; console.log(&amp;#34;clicked&amp;#34;)); setTimeout(() =&amp;gt; console.log(&amp;#34;done&amp;#34;), 1000); localStorage.setItem(&amp;#34;user&amp;#34;, &amp;#34;ozgur&amp;#34;); Bunlar sana &amp;ldquo;JavaScript yazıyorum&amp;rdquo; gibi geliyor değil mi? Ama gerçekte olan şu: Bunların hiçbiri JavaScript&amp;rsquo;in kendisi değil.
JavaScript Nedir? JavaScript, ECMAScript standardına bağlı bir programlama dilidir. Sana şunları sunar:
let const if for function class Array Object String Number Promise Symbol Map Set Ama asıl sihir nerede biliyor musun? JavaScript&amp;rsquo;e bir vücut kazandıran şey, çalıştığı ortamın sunduğu API’lerdir.</description></item><item><title>Kalbini Kırarım</title><link>https://ozgurvurgun.github.io/posts/kalbini-kirarim/</link><pubDate>Sat, 26 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/kalbini-kirarim/</guid><description>Denk gelmişsinizdir, hatta bizzat siz de yapmış olabilirsiniz. Tartışma sırasında, bir noktada karşı tarafa şöyle dediğiniz olmuştur:
Kalbini kırmak istemiyorum.
Peki burada gerçekten ne kast ediliyor? Hakikaten kalp kırmak istemiyor muyuz, yoksa bu laf başlı başına oldukça kırıcı, içinde birçok aşağılayıcı ima barındıran bir tehdit mi?
Denk geldiğim örneklerde, ve zaman zaman kendi içimde de, fark ettiğim kadarıyla bu ve benzeri sözlerle genellikle şunu ima ediyoruz:
Seni derinden sarsacak durumlarını, acizliklerini, zayıf yönlerini biliyorum.</description></item><item><title>Tarayıcıda Neden C++ Çalışmazdı?</title><link>https://ozgurvurgun.github.io/posts/tarayicida-neden-c++-calismazdi/</link><pubDate>Sat, 26 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/tarayicida-neden-c++-calismazdi/</guid><description>Şunu web kariyerimizin ilk noktalarında çoğumuz düşündük:
Madem C++ çok hızlı bir dil, neden tarayıcılar doğrudan C++ çalıştırmıyor da JavaScript gibi bir ara katmanla uğraşıyoruz?
Çok makul bir soru. Ama cevabı sadece teknik değil; biraz tarih, biraz felsefe, biraz da insanlık hali.
Web &amp;ldquo;Devrimle&amp;rdquo; Değil, Yamayla Gelişti
Web’in ilk amacı sadece belge sunmaktı. 90’larda insanlar sadece &amp;lt;h1&amp;gt;Hoşgeldiniz&amp;lt;/h1&amp;gt; yazıyordu.
Dinamiklik? Yoktu.
Zamanla:
Formlar geldi Butonlar kondu “Şuna tıklayınca bu olsun” denmeye başlandı Ve çözüm arandı.</description></item><item><title>private</title><link>https://ozgurvurgun.github.io/posts/private-1/</link><pubDate>Tue, 22 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/private-1/</guid><description>
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</description></item><item><title>Kuantum Dolanıklık</title><link>https://ozgurvurgun.github.io/posts/kunatum-dolaniklik/</link><pubDate>Fri, 18 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/kunatum-dolaniklik/</guid><description>Nedir Ulan Bu Dolanıklık Kuantum fiziği, &amp;ldquo;la bu nasıl olabilir?&amp;rdquo; dedirten tufahlıklarıyla meşhurdur. Ama içlerinde öyle bir mevzu var ki, hem deli gibi merak uyandırır hme de anlamaya çalıştıkça daha da gizemli hale gelir. O mevzu Kuantum Doalnıklık (Entaglement).
Einstein buna &amp;ldquo;mesafeden ürkütücü etki&amp;rdquo; dedi ve haksız da sayılmazdı. Çünkü bu olay birbirinden ışık yılları uzaklıktaki iki parçacığın sanki gizemli bir kabloyla birbirlerine bağlıymış gibi davranması anlamına geliyor.
Dolanıklık Nedir? En basit haliyle:</description></item><item><title>Links</title><link>https://ozgurvurgun.github.io/links/</link><pubDate>Fri, 18 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/links/</guid><description>Category Theory: https://en.wikipedia.org/wiki/Category_theory Type Theory: https://en.wikipedia.org/wiki/Type_theory Set Theory: https://en.wikipedia.org/wiki/Set_theory Agda Programming Language: https://agda.readthedocs.io/en/latest/getting-started/what-is-agda.html Gödel Machine: https://en.wikipedia.org/wiki/G%C3%B6del_machine String Theory: https://en.wikipedia.org/wiki/String_theory Can machines think?: https://courses.cs.umbc.edu/471/papers/turing.pdf Lambda Calculus: https://en.wikipedia.org/wiki/Lambda_calculus Philip Wadler - Propositions as Types: https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf Logic in Computer Science: https://en.wikipedia.org/wiki/Logic_in_computer_science Halting Problem: https://en.wikipedia.org/wiki/Halting_problem 📚 Types and Programming Languages - Benjamin C. Pierce:
https://theswissbay.ch/pdf/Gentoomen%20Library/Maths/Comp%20Sci%20Math/Benjamin_C._Pierce-Types_and_Programming_Languages-The_MIT_Press%282002%29.pdf 📚 Deep Learning - Ian Goodfellow, Yoshua Bengio, Aaron Courville:
https://www.deeplearningbook.org/ 📚 Gödel, Escher, Bach - Douglas Hofstadter:</description></item><item><title>Reaktif Programlama</title><link>https://ozgurvurgun.github.io/posts/reaktif-programlama/</link><pubDate>Tue, 15 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/reaktif-programlama/</guid><description>Nedir Bu Reaktif Programlama Reaktif programlama, zaman içinde değişen verilerle çalışan sistemler için geliştirilmiş bir programlama paradigmasıdır. Temel fikir, değişen verilere otomatik tepki veren sistemler oluşturmaktır. Geleneksel yöntemde veriyi çeker, kontrol eder ve ona göre reaksiyon alırız. Reaktif programlamadaysa veri otomatize bir şekilde akar.
Neden Ortaya Çıktı? Modern uygulamalar artık çok fazla gerçek zamanlı veriyle çalışıyor, çok sayıda kullanıcıya hizmet veriyor. Yani aynı anda birden fazla işlemi (asenkron akışı) iyi yönetmek gerekiyor.</description></item><item><title>Bottleneck</title><link>https://ozgurvurgun.github.io/shorts/bottleneck/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/shorts/bottleneck/</guid><description>Türkçesi “şişe ağzı” anlamına geliyor. Bu kavramı bir analojiyle anlamaya çalışalım. Aslında kelimenin kendi anlamı bile meseleyi güzel özetliyor. Üzerine biraz yürüyelim.
Pet şişeler genelde ağız kısmına doğru daralır. Şişenin içindeki sıvıyı dışarı çıkarmak isterseniz, ister istemez bu dar ağızdan geçirmek zorundasınız. Yani dış etkilerden bağımsız bir senaryoda, sıvının dışarı çıkış hızını şişenin ağzı belirler.
IT dünyasına gelirsek, bu analoji şu şekilde birebir oturur: Çok taşaklı bir sunucunuz, hayvani bir internet hızınız olabilir.</description></item><item><title>Hello, World. Built the World First.</title><link>https://ozgurvurgun.github.io/posts/hello-world/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/hello-world/</guid><description>Programlamaya ilk başladığınızda, genelde dilin output fonksiyonunu kullanarak terminale &amp;ldquo;Hello World&amp;rdquo; yazdırırsınız. Bu, programlama dünyasına attığınız ilk adımdır;
# Python print(&amp;#34;Hello, World!&amp;#34;) // Java public class Main { public static void main(String[] args) { System.out.println(&amp;#34;Hello, World!&amp;#34;); } } // Go package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, World!&amp;#34;) } // Rust fn main() { println!(&amp;#34;Hello, World!&amp;#34;); } -- Haskell main = putStrLn &amp;#34;Hello, World!&amp;#34; gibi&amp;hellip; Az önce internette buna dair bir geyik gördüm.</description></item><item><title>About</title><link>https://ozgurvurgun.github.io/about/</link><pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/about/</guid><description>Hi,
I&amp;rsquo;m Özgür Vurgun a software developer.
I mainly focus on backend development, system tinkering, automation, and building tools that make my own work easier.
Besides my daily work, I enjoy trying out new languages, exploring frameworks, and understanding how things work from the root.
When I write code, I care as much about why something is done a certain way as how it’s done. Sometimes, I build the same thing three times in different ways just to see how it really works under the hood.</description></item><item><title>Cihazınız bu hesap için Netflix Hanesine dahil değil.</title><link>https://ozgurvurgun.github.io/posts/cihaziniz-bu-hesap-icin-netflix-hanesine-dahil-degil/</link><pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/posts/cihaziniz-bu-hesap-icin-netflix-hanesine-dahil-degil/</guid><description>Bugün Netflix hesabına hane dışından erişmeye çalışırken ekranıma şu meşhur uyarı düştü:
&amp;ldquo;Cihazınız bu hesap için Netflix Hanesine dahil değil.&amp;rdquo;
&amp;ldquo;Tamam&amp;rdquo; dedim, &amp;ldquo;ben seni dahil ederim…&amp;rdquo; 😈
Engeli nasıl gördüm? Tam ekran bir engel:
Arka planda video sayfası var ama oynatılmıyor. Üstte Hesap Oluştur butonu, Geçici Olarak İzle veya Oturumu Kapat seçenekleri var. 🧙‍♂️ Büyü neydi? Önce engeli ortadan kaldırmak için klasik display: none manevrasını yaptım. Ardından fark ettim ki video DOM’da duruyor ama kendini oynatmıyor.</description></item><item><title>Projects</title><link>https://ozgurvurgun.github.io/projects/</link><pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/projects/</guid><description>Projects page</description></item><item><title>Class</title><link>https://ozgurvurgun.github.io/class/</link><pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/class/</guid><description>17 Haftada Web Geliştirme Uzmanı Olun! Web programlamaya adım atın! Modern teknikler ve kapsamlı ders içerikleriyle, PHP, HTML, CSS ve JavaScript dünyasını keşfedin.
Kurs Detayları Web Programlamaya Giriş
Web programlamayı keşfedelim ve nedir anlayalım? Backend ve Frontend gibi web programlama kısımlarını anlayalım. PHP&amp;rsquo;nin web programlamanın neresinde durduğuna bakalım. Hazırlık
PHP yorumlayıcısı hakkında bilgi edinelim. İşletim sistemi farkı nelere sebep olur anlayalım. PHP&amp;rsquo;yi bilgisayarımıza kuralım (windows, mac, linux). Kodları nerede yazacağız ve ne farkeder?</description></item><item><title>Subscribe</title><link>https://ozgurvurgun.github.io/subscribe/</link><pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><guid>https://ozgurvurgun.github.io/subscribe/</guid><description>You can subscribe to my blog via email. Just you need to fill the form in the URL below. I&amp;rsquo;ll send every new blog post to your email.
Bloguma eposta ile abonelik gerçekleştirebilirsiniz. Alttaki bağlantıdaki formu doldurmanız yeterli. Her yeni blog içeriğini eposta adresinize göndereceğim.
Subscribe via Email Eposta ile Abone ol</description></item></channel></rss>